# RDR 运维分析功能文档

## 概述

RDR 现在提供全面的运维分析功能，帮助运维人员深入了解 Redis RDB 文件，及时发现问题并获得优化建议。

## 核心功能

### 1. 健康评分系统 (Health Score)

**评分范围**: 0-100

**评级标准**:
- 90-100: 优秀 (Excellent) - 绿色
- 75-89: 良好 (Good) - 蓝色
- 60-74: 一般 (Fair) - 橙色
- 40-59: 较差 (Poor) - 深橙色
- 0-39: 危险 (Critical) - 红色

**评分依据**:
- 异常问题数量和严重程度
- 键数量是否过多
- 平均键大小是否合理
- 内存使用模式
- 数据结构效率

### 2. 异常检测 (Anomaly Detection)

系统自动检测以下异常情况：

#### 内存相关异常
- **超大键检测**
  - 警告阈值: 10MB
  - 危险阈值: 50MB
  - 影响: 阻塞操作、内存压力、慢复制
  - 建议: 拆分为小块或使用不同数据结构

- **内存热点**
  - 检测单个前缀占用 >30% 内存
  - 影响: 集群模式下负载不均
  - 建议: 优化键分布策略

- **数据类型主导**
  - 检测单个类型占用 >50% 内存
  - 影响: 可能有优化空间
  - 建议: 评估数据类型使用合理性

#### 键相关异常
- **键数量过多**
  - 警告阈值: 1000万个键
  - 影响: KEYS、SCAN、BGSAVE 操作变慢
  - 建议: 实施过期策略或数据归档

- **微小键爆炸**
  - 检测大量 <100 字节的键
  - 影响: 键存储开销 > 值存储开销
  - 建议: 使用 Hash 数据结构分组

#### 性能相关异常
- **巨型集合**
  - 阈值: 100万个元素
  - 影响: 操作可能阻塞 Redis 造成延迟
  - 建议: 拆分为小集合或改变访问模式

- **键大小不一致**
  - 检测同类型键大小变化大
  - 影响: 可能使用了次优数据结构
  - 建议: 审查优化机会

#### 集群相关异常
- **槽位不平衡**
  - 阈值: >50% 不平衡度
  - 影响: 热点和性能问题
  - 建议: 重新平衡槽位或审查键分布

### 3. 内存热点分析 (Memory Hotspots)

**分析维度**:
1. **按键前缀分析**
   - 识别 Top 20 内存消耗前缀
   - 显示每个前缀的:
     - 内存使用量
     - 键数量
     - 占比百分比
     - 平均键大小

2. **按数据类型分析**
   - String, Hash, List, Set, ZSet 等
   - 各类型的内存占用和键数量
   - 平均大小和分布

**可视化**:
- 柱状图展示内存分布
- 百分比进度条
- 颜色编码 (绿色 <15%, 橙色 15-30%, 红色 >30%)

### 4. 键模式分析 (Key Patterns)

识别 Top 50 常见键命名模式:
- 模式示例
- 键数量
- 总内存使用
- 平均内存
- 占比百分比

**用途**:
- 识别业务模块内存占用
- 发现命名规范问题
- 辅助容量规划

### 5. 数据类型效率分析 (Type Efficiency)

**指标**:
- **平均大小** (Avg Size)
- **中位数大小** (Median Size)
- **P95 大小** (95th Percentile)
- **P99 大小** (99th Percentile)
- **效率评分** (0-100)
  - 基于大小变异系数
  - >70: 良好
  - 50-70: 一般
  - <50: 需要优化

**建议**:
- 效率低的 String 类型建议使用 Hash
- 可节省 30-50% 内存

### 6. 集群槽位分析 (Cluster Slot Analysis)

**仅适用于集群模式**

**分析内容**:
- 槽位不平衡度计算
- Top 10 内存消耗槽位
- 每个槽位的:
  - 槽位编号
  - 键数量
  - 内存使用
  - 占比百分比

### 7. 优化建议系统 (Recommendations)

**建议分级**:
- 优先级 1-5 (1 最高)
- 实施难度: low/medium/high
- 预期影响说明

**建议类别**:

#### 内存优化
- **启用内存驱逐策略**
  - 适用场景: >10GB 内存
  - 操作: 配置 maxmemory 和 maxmemory-policy
  - 影响: 防止 OOM 自动清理数据
  - 难度: 低

#### TTL 管理
- **为大键设置过期时间**
  - 适用场景: 大量无 TTL 的大键
  - 影响: 防止内存无限增长
  - 难度: 中

#### 性能优化
- **使用 Hash 优化小字符串**
  - 适用场景: String 类型效率 <60%
  - 影响: 可节省 30-50% 内存
  - 难度: 高 (需要代码改动)

#### 监控
- **启用慢日志**
  - 配置: slowlog-log-slower-than 10000
  - 影响: 识别性能瓶颈
  - 难度: 低

## API 接口

### 完整分析
```
GET /api/ops/analysis/:instance_name
```

返回所有运维分析数据:
- 健康评分
- 所有异常
- 内存热点
- 键模式
- 类型效率
- 槽位分析
- 优化建议

### 仅异常
```
GET /api/ops/anomalies/:instance_name
```

返回按级别分组的异常:
- critical: 严重问题
- warning: 警告
- info: 信息

### 仅建议
```
GET /api/ops/recommendations/:instance_name
```

返回优化建议列表

### 健康检查
```
GET /api/ops/health/:instance_name
```

快速健康检查:
- 健康评分
- 健康状态 (excellent/good/fair/poor/critical)
- 严重问题数
- 警告数
- 总异常数
- 建议数

## 使用场景

### 场景 1: 日常巡检
1. 查看健康评分
2. 检查是否有严重或警告异常
3. 查看内存热点是否有变化
4. 关注 Top 10 优化建议

### 场景 2: 容量规划
1. 分析内存热点和键模式
2. 识别增长最快的业务模块
3. 评估类型效率，计算可优化空间
4. 根据建议制定优化计划

### 场景 3: 性能优化
1. 检测巨型集合和超大键
2. 查看类型效率评分
3. 识别可拆分的数据结构
4. 根据建议实施优化

### 场景 4: 故障排查
1. 查看严重异常
2. 分析内存热点变化
3. 检查槽位平衡（集群）
4. 定位问题根源

### 场景 5: 迁移评估
1. 完整分析现有数据特征
2. 评估优化空间
3. 规划迁移方案
4. 验证迁移后效果

## 最佳实践

### 1. 定期分析
- 建议每天分析一次生产环境 RDB
- 对比历史数据识别趋势
- 及时发现新出现的问题

### 2. 阈值调整
- 根据实际业务调整异常阈值
- 不同环境可能需要不同标准
- 建立自己的基线

### 3. 优先处理
- 优先处理 Critical 级别异常
- 关注优先级 1-2 的建议
- 平衡收益和实施成本

### 4. 持续优化
- 实施建议后重新分析
- 验证优化效果
- 建立优化知识库

### 5. 监控告警
- 健康评分 <60 发告警
- Critical 异常 >0 发告警
- 内存热点 >40% 发告警
- 集成到现有监控系统

## 技术细节

### 异常检测算法
- 基于统计阈值
- 考虑相对值和绝对值
- 多维度综合判断

### 健康评分算法
```
初始分数 = 100
每个 Critical 异常: -15 分
每个 Warning 异常: -8 分
每个 Info 异常: -3 分
键数量 >1亿: -10 分
键数量 >5000万: -5 分
平均键大小 >1MB: -10 分
平均键大小 >100KB: -5 分
最低分数 = 0
```

### 效率评分算法
```
计算键大小的变异系数 (CV)
CV = 标准差 / 平均值
效率 = max(0, 100 - CV * 100)
```

## 示例输出

### 健康评分示例
```json
{
  "health_score": 75,
  "health_status": "good",
  "critical_issues": 0,
  "warnings": 3,
  "total_anomalies": 8
}
```

### 异常示例
```json
{
  "level": "warning",
  "category": "memory",
  "title": "Large Keys Detected",
  "description": "Found 15 keys larger than 10MB",
  "impact": "May cause performance degradation",
  "suggestion": "Review large keys and consider optimization",
  "value": "15 keys"
}
```

### 建议示例
```json
{
  "priority": 1,
  "category": "ttl",
  "title": "Implement TTL for Large Keys",
  "description": "Many large keys appear to have no expiration",
  "action": "Review and set appropriate TTL values",
  "impact": "Prevents unbounded memory growth",
  "effort": "medium"
}
```

## 常见问题

### Q: 健康评分多少算正常？
A: 80+ 算健康，60-80 需要关注，<60 需要立即优化。

### Q: 如何解读内存热点？
A: >30% 的热点需要特别关注，可能导致负载不均或单点压力。

### Q: 所有建议都要实施吗？
A: 优先实施优先级 1-2 且实施难度低的建议，高难度建议需要评估投入产出比。

### Q: 分析会影响性能吗？
A: 分析是离线进行的，对线上 Redis 无影响。

### Q: 多久分析一次比较好？
A: 建议每天分析一次，重大变更后也应该分析。

### Q: 可以自定义阈值吗？
A: 当前版本阈值是固定的，后续版本会支持自定义配置。

## 路线图

### 计划中的功能
- [ ] 自定义阈值配置
- [ ] 历史趋势对比
- [ ] 告警规则配置
- [ ] 自动生成优化脚本
- [ ] PDF 报告导出
- [ ] 多实例对比分析
- [ ] TTL 过期时间分析
- [ ] 访问热度预测 (需要 INFO 数据)
- [ ] 成本分析 (云环境)
- [ ] AI 辅助优化建议
